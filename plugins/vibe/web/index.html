<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vibe Pipeline Dashboard</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéØ</text></svg>">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #1e1e2e; --surface0: #313244; --surface1: #45475a; --surface2: #585b70;
      --overlay0: #6c7086; --text: #cdd6f4; --subtext0: #a6adc8; --subtext1: #bac2de;
      --blue: #89b4fa; --green: #a6e3a1; --red: #f38ba8; --yellow: #f9e2af;
      --purple: #cba6f7; --cyan: #89dceb; --pink: #f5c2e7; --orange: #fab387;
    }
    body { font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', 'Menlo', monospace; background: var(--bg); color: var(--text); overflow: hidden; }
    .layout { display: grid; grid-template-columns: var(--sidebar-w, 230px) 1fr; height: 100vh; transition: grid-template-columns 0.3s ease; }
    .layout.collapsed { --sidebar-w: 52px; }

    /* Sidebar */
    .sidebar { background: var(--surface0); border-right: 1px solid var(--surface1); display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; transition: width 0.3s ease, min-width 0.3s ease; }
    .sb-top { padding: 10px 12px; display: flex; align-items: center; gap: 8px; border-bottom: 1px solid var(--surface1); min-height: 40px; }
    .sb-toggle { width: 28px; height: 28px; border-radius: 6px; background: var(--surface1); border: none; color: var(--text); cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: background 0.2s; }
    .sb-toggle:hover { background: var(--surface2); }
    .conn { font-size: 11px; display: flex; align-items: center; gap: 6px; white-space: nowrap; overflow: hidden; transition: opacity 0.3s; }
    .dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; transition: background 0.3s; }
    .dot.on { background: var(--green); box-shadow: 0 0 6px var(--green); }
    .dot.off { background: var(--orange); animation: blink 1s infinite; }
    .sb-body { padding: 8px; display: flex; flex-direction: column; gap: 4px; flex: 1; }
    .collapsed .conn span:not(.dot) { display: none; }
    .collapsed .sb-body { padding: 4px; }

    /* Sidebar Groups */
    .group-hdr { display: flex; align-items: center; justify-content: space-between; padding: 6px 4px 2px; }
    .group-hdr h2 { font-size: 10px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1.5px; white-space: nowrap; overflow: hidden; }
    .group-hdr .count { font-size: 9px; color: var(--overlay0); background: var(--surface1); padding: 1px 5px; border-radius: 8px; flex-shrink: 0; }
    .group-sep { font-size: 9px; color: var(--overlay0); text-transform: uppercase; letter-spacing: 1px; margin-top: 6px; padding: 4px 4px 2px; border-top: 1px solid var(--surface1); display: flex; align-items: center; justify-content: space-between; white-space: nowrap; overflow: hidden; }

    /* Session Card */
    .sc { padding: 8px 10px; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 1px solid transparent; position: relative; }
    .sc:hover { background: var(--surface1); }
    .sc.selected { background: var(--surface1); border-color: var(--blue); }
    .sc.live { border-color: var(--green); box-shadow: 0 0 8px rgba(166,227,161,0.15); }
    .sc.live.selected { border-color: var(--green); box-shadow: 0 0 12px rgba(166,227,161,0.2); }
    .sc.done { opacity: 0.55; }
    .sc.done:hover { opacity: 0.8; }
    .sc.stale { opacity: 0.4; }
    .sc.stale:hover { opacity: 0.7; }
    .sc .x { position: absolute; top: 3px; right: 5px; width: 16px; height: 16px; border-radius: 50%; background: var(--surface2); color: var(--text); font-size: 9px; line-height: 16px; text-align: center; cursor: pointer; opacity: 0; transition: all 0.2s; border: none; font-family: inherit; }
    .sc:hover .x { opacity: 0.5; }
    .sc .x:hover { opacity: 1; background: var(--red); color: var(--bg); }
    .sc-title { font-size: 11px; font-weight: 600; display: flex; align-items: center; gap: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sc-title .badge { font-size: 8px; padding: 1px 4px; border-radius: 3px; font-weight: 400; }
    .sc-title .badge.pass { background: rgba(166,227,161,0.2); color: var(--green); }
    .sc-title .badge.fail { background: rgba(243,139,168,0.2); color: var(--red); }
    .live-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--green); animation: livePulse 2s ease infinite; flex-shrink: 0; }
    .sc-sub { font-size: 9px; color: var(--overlay0); margin-top: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sc-meta { font-size: 10px; color: var(--subtext0); margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .sc-bar { height: 3px; background: var(--surface1); border-radius: 2px; margin-top: 4px; overflow: hidden; }
    .sc-bar-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--green)); border-radius: 2px; transition: width 0.5s; }
    .sc-bar-fill.complete { background: var(--green); }
    .cleanup-btn { font-size: 9px; color: var(--subtext0); background: none; border: 1px solid var(--surface2); border-radius: 3px; padding: 1px 6px; cursor: pointer; font-family: inherit; transition: all 0.2s; }
    .cleanup-btn:hover { background: var(--red); color: var(--bg); border-color: var(--red); }
    .stale-toggle { font-size: 9px; color: var(--overlay0); background: none; border: none; cursor: pointer; font-family: inherit; padding: 4px 4px 2px; display: flex; align-items: center; gap: 4px; width: 100%; border-top: 1px solid var(--surface1); margin-top: 6px; transition: color 0.2s; }
    .stale-toggle:hover { color: var(--subtext0); }

    /* Collapsed sidebar mini cards */
    .collapsed .sc { padding: 6px; text-align: center; }
    .collapsed .sc-title, .collapsed .sc-sub, .collapsed .sc-meta, .collapsed .sc-bar, .collapsed .sc .x, .collapsed .group-hdr, .collapsed .group-sep, .collapsed .cleanup-btn, .collapsed .stale-toggle, .collapsed .sc-res { display: none; }
    .collapsed .sc::before { content: attr(data-pct); font-size: 9px; color: var(--subtext0); }

    @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
    @keyframes livePulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }

    /* Main */
    .main { padding: 16px 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 14px; }
    .main h1 { font-size: 15px; display: flex; align-items: center; gap: 8px; flex-wrap: nowrap; min-height: 32px; }
    .task-badge { font-size: 10px; padding: 2px 8px; border-radius: 6px; background: var(--surface1); color: var(--subtext0); font-weight: 500; flex-shrink: 0; }

    /* Progress */
    .progress-bar { height: 5px; background: var(--surface1); border-radius: 3px; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, var(--blue), var(--green)); border-radius: 3px; transition: width 0.8s cubic-bezier(0.4,0,0.2,1); }
    .progress-fill.complete { background: linear-gradient(90deg, var(--green), var(--cyan), var(--green)); background-size: 200% 100%; animation: shimmer 2s linear infinite; }
    .celebrate { position: relative; }
    .celebrate::after { content: 'üéâ'; position: absolute; right: -24px; top: 50%; transform: translateY(-50%); font-size: 16px; animation: celebratePop 0.5s cubic-bezier(0.175,0.885,0.32,1.275); }
    @keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    @keyframes celebratePop { 0% { transform: translateY(-50%) scale(0); } 100% { transform: translateY(-50%) scale(1); } }

    /* Agent ÁãÄÊÖãÈù¢ÊùøÔºàÁ∞°ÂåñÁâàÔºâ */
    .agent-panel { background: var(--surface0); border-radius: 10px; padding: 14px 16px; border: 1px solid var(--surface1); }
    .agent-panel-hdr { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .agent-panel-hdr h3 { font-size: 11px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; margin: 0; }
    .agent-panel-stats { display: flex; gap: 12px; }
    .agent-panel-stat { font-size: 10px; color: var(--subtext0); }
    .agent-panel-stat .num { font-weight: 700; color: var(--text); }
    /* Á∞°Âåñ‰∏âÊ¨ÑÔºö[Ááà] [ÂêçÁ®±] [ÁãÄÊÖã] [ËÄóÊôÇ] */
    .agent-row { display: grid; grid-template-columns: 16px 1fr auto 48px; column-gap: 8px; align-items: center; padding: 5px 4px; font-size: 11px; border-bottom: 1px solid rgba(69,71,90,0.15); transition: background 0.15s; }
    .agent-row:last-child { border-bottom: none; }
    .agent-row:hover { background: rgba(69,71,90,0.1); border-radius: 4px; }
    .al { width: 8px; height: 8px; border-radius: 50%; justify-self: center; }
    .al.running { background: var(--green); box-shadow: 0 0 8px var(--green); animation: alPulse 1.5s ease infinite; }
    .al.completed { background: var(--surface2); opacity: 0.6; }
    .al.error { background: var(--red); box-shadow: 0 0 6px var(--red); animation: alPulse 1.5s ease infinite; }
    .al.delegating { background: var(--purple); box-shadow: 0 0 8px var(--purple); animation: alPulse 1.5s ease infinite; }
    .al.idle { background: var(--surface2); opacity: 0.5; }
    .al.pass { background: var(--green); opacity: 0.8; }
    @keyframes alPulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
    .agent-name { font-weight: 600; display: flex; align-items: center; gap: 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .agent-status-text { font-size: 10px; color: var(--subtext0); white-space: nowrap; }
    .agent-status-text.running { color: var(--green); }
    .agent-status-text.error { color: var(--red); }
    .agent-status-text.delegating { color: var(--purple); }
    .agent-status-text.pass { color: var(--green); }
    .agent-dur { font-size: 10px; color: var(--subtext0); text-align: right; font-variant-numeric: tabular-nums; }
    .agent-group-label { font-size: 9px; color: var(--overlay0); text-transform: uppercase; letter-spacing: 1.2px; padding: 6px 4px 2px; }
    .agent-sep { border-top: 1px dashed rgba(69,71,90,0.3); margin: 4px 0; }
    @media (max-width: 1100px) {
      .agent-row { font-size: 10px; }
    }

    /* Áµ±Ë®àÂç°Áâá */
    .stats-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; }
    .stat-card { background: var(--surface0); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--surface1); display: flex; flex-direction: column; gap: 4px; min-width: 0; position: relative; cursor: default; transition: border-color 0.2s, background 0.2s; }
    .stat-card:hover { border-color: var(--surface2); }
    .stat-card .stat-label { font-size: 9px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .stat-card .stat-value { font-size: 20px; font-weight: 700; color: var(--text); font-variant-numeric: tabular-nums; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .stat-card .stat-sub { font-size: 9px; color: var(--overlay0); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .stat-card.warn { border-left: 3px solid var(--yellow); background: rgba(249,226,175,0.04); }
    .stat-card.danger { border-left: 3px solid var(--red); background: rgba(243,139,168,0.04); }
    .stat-hint { font-size: 8px; font-weight: 500; line-height: 1.2; }
    .stat-hint.warn { color: var(--yellow); }
    .stat-hint.danger { color: var(--red); }
    .stat-card[data-tip]:hover::after { content: attr(data-tip); position: absolute; top: calc(100% + 6px); left: 0; background: var(--surface1); color: var(--subtext1); padding: 6px 10px; border-radius: 6px; font-size: 9px; white-space: normal; max-width: 220px; line-height: 1.4; z-index: 100; pointer-events: none; box-shadow: 0 4px 12px rgba(0,0,0,0.4); border: 1px solid var(--surface2); }
    @media (max-width: 1100px) { .stats-grid { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width: 700px) { .stats-grid { grid-template-columns: 1fr; } }

    /* ÂãïÊÖã Pipeline ÈÄ≤Â∫¶Ê¢ù */
    .pipeline-progress { background: var(--surface0); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--surface1); }
    .pipeline-progress h3 { font-size: 11px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; }
    .pipeline-stages-bar { display: flex; gap: 4px; align-items: flex-end; flex-wrap: nowrap; overflow-x: auto; padding-bottom: 2px; }
    .ps-block { flex: 1; min-width: 36px; max-width: 80px; display: flex; flex-direction: column; gap: 4px; align-items: center; }
    .ps-label { font-size: 9px; color: var(--subtext0); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; text-align: center; }
    .ps-bar { width: 100%; height: 8px; border-radius: 4px; background: var(--surface1); position: relative; overflow: hidden; }
    .ps-bar.completed { background: var(--green); }
    .ps-bar.active { background: var(--blue); animation: pulse 1.5s infinite; }
    .ps-bar.failed { background: var(--red); }
    .ps-bar.skipped { background: var(--surface1); opacity: 0.5; }
    @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }

    /* DAG ÊµÅÁ®ãÂúñÔºàSVG + HTML Ê∑∑ÂêàÔºâ */
    .dag-container { position: relative; overflow-x: auto; overflow-y: hidden; min-height: 200px; }
    .dag-node { position: absolute; background: var(--surface0); border: 2px solid var(--surface1); border-radius: 8px; padding: 8px 12px; cursor: pointer; transition: all 0.3s; display: flex; flex-direction: column; align-items: center; gap: 3px; min-width: 80px; text-align: center; z-index: 2; }
    .dag-node:hover { border-color: var(--blue); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    .dag-node.completed { border-color: var(--green); background: rgba(166,227,161,0.05); }
    .dag-node.active { border-color: var(--blue); background: rgba(137,180,250,0.05); animation: dagPulse 2s ease-in-out infinite; }
    .dag-node.failed { border-color: var(--red); background: rgba(243,139,168,0.05); animation: dagShake 0.5s ease-in-out; }
    .dag-node.skipped { opacity: 0.35; filter: grayscale(0.8); border-style: dashed; }
    .dag-node.pending { opacity: 0.5; }
    .dag-node.selected { border-color: var(--yellow); box-shadow: 0 0 0 1px var(--yellow); }
    @keyframes dagPulse {
      0%,100% { box-shadow: 0 0 8px rgba(137,180,250,0.2); }
      50% { box-shadow: 0 0 18px rgba(137,180,250,0.4); }
    }
    @keyframes dagShake {
      0%,100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      75% { transform: translateX(2px); }
    }
    .dag-emoji { font-size: 18px; line-height: 1; }
    .dag-label { font-size: 10px; font-weight: 700; letter-spacing: 0.5px; }
    .dag-status { font-size: 9px; }
    .dag-node.completed .dag-status { color: var(--green); }
    .dag-node.active .dag-status { color: var(--blue); }
    .dag-node.failed .dag-status { color: var(--red); }
    .dag-node.pending .dag-status { color: var(--overlay0); }
    .dag-svg { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1; }
    .dag-edge { fill: none; stroke-width: 1.5; }
    .dag-edge.completed { stroke: var(--green); opacity: 0.7; }
    .dag-edge.active { stroke: var(--blue); stroke-dasharray: 6 3; animation: dashFlow 1s linear infinite; }
    .dag-edge.pending { stroke: var(--surface2); stroke-dasharray: 4 4; }
    @keyframes dashFlow { 0% { stroke-dashoffset: 0; } 100% { stroke-dashoffset: -18; } }

    /* Phase ÂàÜÁµÑÊ°Ü */
    .dag-phase { position: absolute; border: 1px solid rgba(137,180,250,0.2); border-radius: 10px; background: rgba(137,180,250,0.03); z-index: 0; }
    .dag-phase-title { position: absolute; top: -10px; left: 8px; font-size: 9px; color: var(--blue); background: var(--bg); padding: 0 4px; white-space: nowrap; }

    /* DAG Ë©≥ÊÉÖÈù¢Êùø */
    .dag-detail { background: var(--surface0); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--surface1); min-height: 80px; transition: all 0.3s; }
    .dag-detail h4 { font-size: 11px; color: var(--text); margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
    .dag-detail-row { display: flex; justify-content: space-between; padding: 2px 0; font-size: 11px; }
    .dag-detail-row .label { color: var(--subtext0); }
    .dag-detail-row .value { font-weight: 600; }
    .dag-detail-empty { color: var(--overlay0); font-size: 10px; }
    .rh-round { padding: 2px 0 2px 8px; border-left: 2px solid rgba(69,71,90,0.3); margin: 2px 0; font-size: 9px; }
    .rh-round.pass { border-left-color: var(--green); }
    .rh-round.fail { border-left-color: var(--red); color: var(--red); }

    /* MCP Áµ±Ë®à */
    .mcp-stats { background: var(--surface0); border-radius: 10px; padding: 12px 16px; border: 1px solid var(--surface1); }
    .mcp-stats h3 { font-size: 11px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; display: flex; align-items: center; justify-content: space-between; }
    .mcp-stats h3 .mcp-total { font-size: 9px; font-weight: 400; }
    .mcp-row { display: flex; align-items: center; gap: 8px; padding: 3px 0; font-size: 11px; }
    .mcp-row .mcp-server { font-weight: 600; min-width: 90px; color: var(--cyan); }
    .mcp-row .mcp-count { min-width: 36px; text-align: right; font-variant-numeric: tabular-nums; color: var(--subtext0); }
    .mcp-row .mcp-bar { flex: 1; height: 4px; background: var(--surface1); border-radius: 2px; overflow: hidden; }
    .mcp-row .mcp-fill { height: 100%; background: var(--cyan); border-radius: 2px; transition: width 0.5s; }
    .mcp-row .mcp-methods { font-size: 9px; color: var(--overlay0); max-width: 200px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

    /* Info Cards */
    .cards { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .card { background: var(--surface0); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--surface1); transition: border-color 0.2s; min-width: 0; }
    .card:hover { border-color: var(--surface2); }
    .card h3 { font-size: 10px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
    .row { display: flex; justify-content: space-between; align-items: baseline; padding: 2px 0; font-size: 11px; gap: 8px; }
    .row .label { color: var(--subtext0); flex-shrink: 0; }
    .row .value { font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-align: right; }

    /* Timeline */
    .timeline { background: var(--surface0); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--surface1); flex: 1; min-height: 80px; overflow: hidden; }
    .timeline h3 { font-size: 10px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
    .tl-item { display: flex; align-items: center; gap: 8px; padding: 4px 2px; font-size: 11px; border-bottom: 1px solid rgba(69,71,90,0.3); animation: slideIn 0.3s ease; min-width: 0; }
    .tl-item:last-child { border-bottom: none; }
    .tl-item:hover { background: rgba(69,71,90,0.15); border-radius: 4px; }
    .tl-item .time { color: var(--overlay0); font-size: 9px; min-width: 52px; font-variant-numeric: tabular-nums; }
    .tl-item .msg { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .tl-item.pass .msg { color: var(--green); }
    .tl-item.fail .msg { color: var(--red); }
    .tl-item.active .msg { color: var(--blue); }
    @keyframes slideIn { from { opacity: 0; transform: translateX(-8px); } to { opacity: 1; transform: translateX(0); } }

    /* Dashboard ÈõôÊ¨Ñ‰ΩàÂ±Ä */
    .dash-grid { display: grid; grid-template-columns: minmax(0, 1fr) minmax(0, 360px); gap: 14px; }
    .dash-left, .dash-right { display: flex; flex-direction: column; gap: 12px; min-height: 0; min-width: 0; }
    .dash-right { max-height: calc(100vh - 130px); overflow-y: auto; }
    @media (max-width: 960px) { .dash-grid { grid-template-columns: 1fr; } .dash-right { max-height: none; overflow-y: visible; } }
    /* Dashboard mini timeline */
    .mini-tl { flex: 1; min-height: 0; display: flex; flex-direction: column; background: var(--surface0); border-radius: 10px; padding: 12px 14px; border: 1px solid var(--surface1); }
    .mini-tl h4 { font-size: 10px; color: var(--subtext0); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; flex-shrink: 0; }
    .mini-tl .tl-items-wrap { flex: 1; overflow-y: auto; min-height: 100px; max-height: 500px; }
    .mini-tl .tl-item { font-size: 10px; }

    /* Main Tabs */
    .main-tabs { display: flex; gap: 0; border-bottom: 1px solid var(--surface1); margin-bottom: 10px; flex-shrink: 0; }
    .main-tab { background: none; color: var(--subtext0); border: none; border-bottom: 2px solid transparent; padding: 7px 14px; font-size: 12px; font-weight: 600; font-family: inherit; cursor: pointer; transition: color 0.15s, border-color 0.15s; white-space: nowrap; }
    .main-tab:hover { color: var(--text); }
    .main-tab.active { color: var(--blue); border-bottom-color: var(--blue); }
    .main-tab .tab-count { font-size: 9px; font-weight: 400; color: var(--overlay0); margin-left: 4px; background: var(--surface1); padding: 1px 5px; border-radius: 8px; }

    /* Timeline full view */
    .tl-full { flex: 1; display: flex; flex-direction: column; min-height: 0; gap: 0; }
    .tl-full .tl-items { flex: 1; overflow-y: auto; min-height: 200px; }

    /* Timeline Tabs + Filter */
    .tl-tabs { display: flex; gap: 0; margin: 0 0 2px; border-bottom: 1px solid var(--surface1); flex-shrink: 0; }
    .tl-tab { background: none; color: var(--subtext0); border: none; border-bottom: 2px solid transparent; padding: 5px 10px; font-size: 10px; font-family: inherit; cursor: pointer; transition: color 0.15s, border-color 0.15s; white-space: nowrap; }
    .tl-tab:hover { color: var(--text); }
    .tl-tab.active { color: var(--blue); border-bottom-color: var(--blue); }
    .tl-filter { display: flex; gap: 4px; margin: 6px 0; align-items: center; }
    .tl-chip { background: var(--surface1); color: var(--subtext0); border: none; border-radius: 4px; padding: 3px 10px; font-size: 9px; font-family: inherit; cursor: pointer; transition: all 0.15s; }
    .tl-chip:hover { background: var(--surface2); color: var(--text); }
    .tl-chip.active { background: var(--blue); color: var(--bg); }

    /* Clear button */
    .tl-clear { background: none; border: 1px solid var(--surface2); color: var(--subtext0); border-radius: 4px; padding: 3px 10px; font-size: 9px; font-family: inherit; cursor: pointer; transition: all 0.15s; margin-left: auto; }
    .tl-clear:hover { border-color: var(--red); color: var(--red); }

    /* Empty */
    .empty { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; gap: 12px; color: var(--subtext0); }
    .empty .icon { font-size: 56px; animation: float 3s ease-in-out infinite; }
    .empty .hint { font-size: 12px; text-align: center; line-height: 1.8; }
    .empty code { background: var(--surface0); padding: 2px 8px; border-radius: 4px; font-size: 11px; color: var(--text); }
    @keyframes float { 0%,100% { transform: translateY(0); } 50% { transform: translateY(-6px); } }

    /* Â∑•ÂÖ∑ÂàóÂàÜÈöîÂçÄ */
    .toolbar-sep { width: 1px; height: 16px; background: var(--surface1); margin: 0 1px; flex-shrink: 0; }
    /* ÈÄ£Á∑öÁáàËôüÔºàÂ∑•ÂÖ∑ÂàóÂÖßÔºâ */
    .conn-indicator { display: flex; align-items: center; gap: 5px; padding: 3px 6px; font-size: 10px; color: var(--subtext0); white-space: nowrap; }

    /* ÂÖ®Ëû¢ÂπïÊ®°Âºè */
    .layout.fullscreen { grid-template-columns: 1fr; }
    .layout.fullscreen .sidebar { display: none; }
    .layout.fullscreen .main { padding: 20px 32px; }

    /* Timeline Êî∂Âêà */
    .timeline .tl-toggle { cursor: pointer; display: flex; align-items: center; justify-content: space-between; user-select: none; }
    .timeline .tl-toggle:hover { color: var(--text); }
    .timeline .tl-toggle .arrow { font-size: 8px; transition: transform 0.2s; }
    .timeline.collapsed .tl-toggle .arrow { transform: rotate(-90deg); }
    .timeline.collapsed .tl-items { display: none; }

    /* Â∑•ÂÖ∑Âàó */
    .toolbar { display: flex; align-items: center; gap: 4px; margin-left: auto; flex-shrink: 0; }
    .tool-btn { background: var(--surface0); border: 1px solid var(--surface1); border-radius: 6px; padding: 4px 9px; font-size: 11px; color: var(--subtext1); cursor: pointer; font-family: inherit; transition: border-color 0.2s, color 0.2s, background 0.2s; display: flex; align-items: center; gap: 4px; white-space: nowrap; }
    .tool-btn:hover { border-color: var(--surface2); color: var(--text); background: var(--surface1); }
    .tool-btn.active { border-color: var(--blue); color: var(--blue); }

    /* Âø´Êç∑ÈçµÊèêÁ§∫ */
    .kbd-toast { position: fixed; top: 12px; right: 12px; background: var(--surface0); border: 1px solid var(--surface1); border-radius: 8px; padding: 8px 14px; font-size: 10px; color: var(--subtext0); z-index: 200; animation: fadeInOut 2s ease forwards; box-shadow: 0 4px 12px rgba(0,0,0,0.4); }
    @keyframes fadeInOut { 0% { opacity: 0; transform: translateY(-8px); } 15% { opacity: 1; transform: translateY(0); } 85% { opacity: 1; } 100% { opacity: 0; } }

    /* Confetti ÊÖ∂Á•ù */
    .confetti-wrap { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 300; overflow: hidden; }
    .confetti-piece { position: absolute; top: -10px; opacity: 0; border-radius: 2px; animation: confettiFall var(--dur, 3s) var(--delay, 0s) ease-out forwards; }
    @keyframes confettiFall {
      0% { transform: translateY(0) rotate(0deg) scale(1); opacity: 1; }
      25% { transform: translateY(25vh) rotate(180deg) scale(0.9); opacity: 1; }
      100% { transform: translateY(105vh) rotate(720deg) scale(0.3); opacity: 0; }
    }

    /* Session Ë≥áÊ∫êÊåáÊ®ô */
    .sc-res { display: flex; gap: 8px; margin-top: 3px; font-size: 9px; color: var(--subtext0); }
    .sc-res-item { display: flex; align-items: center; gap: 3px; }
    .sc-res-bar { width: 28px; height: 3px; background: var(--surface1); border-radius: 2px; overflow: hidden; }
    .sc-res-fill { height: 100%; border-radius: 2px; transition: width 0.5s; }
    .sc-res-fill.ram { background: var(--purple); }

    /* Responsive */
    @media (max-width: 1200px) {
      .dash-grid { grid-template-columns: minmax(0, 1fr) minmax(0, 320px); }
    }
    @media (max-width: 1100px) {
      .dash-grid { grid-template-columns: 1fr; }
      .dash-right { max-height: none; overflow-y: visible; }
    }
    @media (max-width: 700px) {
      .layout, .layout.collapsed { grid-template-columns: 1fr; grid-template-rows: auto 1fr; --sidebar-w: 1fr; }
      .sidebar { max-height: 160px; border-right: none; border-bottom: 1px solid var(--surface1); }
      .sb-body { flex-direction: row; flex-wrap: wrap; gap: 6px; overflow-x: auto; }
      .sc { min-width: 130px; flex-shrink: 0; }
      .cards { grid-template-columns: 1fr; }
      .main { padding: 10px 12px; gap: 12px; }
      .main h1 { font-size: 13px; flex-wrap: wrap; }
      .toolbar { margin-left: 0; flex-wrap: wrap; flex-shrink: unset; }
      .tool-btn { font-size: 10px; padding: 3px 7px; }
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <script type="module">
    import { h, render } from 'https://esm.sh/preact@10.25.4';
    import { useState, useEffect, useRef, useMemo } from 'https://esm.sh/preact@10.25.4/hooks';
    import htm from 'https://esm.sh/htm@3.1.1';
    const html = htm.bind(h);

    // --- ËºîÂä©ÂáΩÂºè ---
    function sid(id) { return id?.length > 8 ? id.slice(0, 8) : id || '‚Äî'; }
    function now() { return new Date().toLocaleTimeString('zh-TW', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' }); }
    function elapsed(iso) {
      if (!iso) return '';
      const d = Math.round((Date.now() - new Date(iso).getTime()) / 1000);
      if (d < 60) return `${d}s`;
      if (d < 3600) return `${Math.floor(d/60)}m`;
      return `${Math.floor(d/3600)}h`;
    }
    function fmtSec(secs) {
      if (!secs && secs !== 0) return '‚Äî';
      if (secs < 60) return Math.round(secs) + 's';
      const m = Math.floor(secs / 60), s = Math.round(secs % 60);
      return s > 0 ? `${m}m${s}s` : `${m}m`;
    }
    function fmtDuration(startedAt) {
      if (!startedAt) return '‚Äî';
      const secs = Math.round((Date.now() - new Date(startedAt).getTime()) / 1000);
      return fmtSec(secs);
    }
    function fmtSize(bytes) {
      if (!bytes) return '‚Äî';
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }
    async function deleteSession(id) {
      try { await fetch(`/api/sessions/${encodeURIComponent(id)}`, { method: 'DELETE' }); } catch {}
    }
    async function cleanupStale() {
      try { await fetch('/api/sessions/cleanup', { method: 'POST' }); } catch {}
    }

    // --- v4 State Áõ¥Êé•Êìç‰ΩúÂáΩÂºèÔºà‰∏ç‰æùË≥¥ adaptStateÔºâ ---
    function getStageStatus(stageId, state) {
      if (!state?.stages?.[stageId]) return 'pending';
      return state.stages[stageId].status; // 'pending' | 'active' | 'completed' | 'failed' | 'skipped'
    }
    function getStageVerdict(stageId, state) {
      const stage = state?.stages?.[stageId];
      if (!stage?.verdict) return null;
      if (typeof stage.verdict === 'object') return stage.verdict.verdict || null;
      return stage.verdict;
    }
    function getStageSeverity(stageId, state) {
      const stage = state?.stages?.[stageId];
      if (!stage?.verdict) return null;
      if (typeof stage.verdict === 'object') return stage.verdict.severity || null;
      return null;
    }
    function getStageDuration(stageId, state) {
      const stage = state?.stages?.[stageId];
      if (!stage?.startedAt || !stage?.completedAt) return null;
      return Math.round((new Date(stage.completedAt) - new Date(stage.startedAt)) / 1000);
    }
    function getPipelineProgress(state) {
      if (!state?.dag) return 0;
      const stages = Object.keys(state.dag);
      if (!stages.length) return 0;
      const done = stages.filter(id => {
        const st = state.stages?.[id]?.status;
        return st === 'completed' || st === 'skipped';
      });
      return Math.round(done.length / stages.length * 100);
    }
    function hasPipeline(state) { return !!(state?.dag && Object.keys(state.dag).length > 0); }
    function isLive(state) { return !!(state?._alive || (state?.activeStages?.length > 0) || state?.pipelineActive); }
    function getActiveStages(state) {
      if (!state?.dag) return [];
      return Object.keys(state.dag).filter(id => state.stages?.[id]?.status === 'active');
    }

    // Session ÂàÜÈ°û
    function sessionCategory(s) {
      if (!s) return 'stale';
      if (s._alive || isLive(s)) return 'live';
      const prog = getPipelineProgress(s);
      if (hasPipeline(s) && prog >= 100) return 'done';
      if (hasPipeline(s)) return 'active';
      const last = s.meta?.lastTransition;
      if (!last) return 'stale';
      const age = Date.now() - new Date(last).getTime();
      if (age > 1800_000) return 'stale';
      return 'active';
    }
    function sessionName(s, registry) {
      if (s?._heartbeatOnly) return 'Â∞çË©±‰∏≠';
      const pid = s?.classification?.pipelineId;
      if (!pid || pid === 'none') return 'Â∞çË©±‰∏≠';
      if (registry?.pipelines?.[pid]) return registry.pipelines[pid].label;
      return pid;
    }
    function currentStageName(s, registry) {
      const active = getActiveStages(s);
      if (!active.length) return null;
      const stage = active[0];
      const stageBase = stage.split(':')[0];
      const meta = registry?.stages?.[stageBase];
      return meta ? `${meta.emoji} ${meta.label}` : stage;
    }

    // --- DAG ÁØÄÈªû‰ΩàÂ±ÄÊºîÁÆóÊ≥ï ---
    // Ê†πÊìö deps Ë®àÁÆóÊãìÊí≤ÊéíÂ∫èÊ∑±Â∫¶ÔºåÂêåÊ∑±Â∫¶ÂûÇÁõ¥ÊéíÂàó
    function computeDagLayout(dag, containerWidth) {
      if (!dag || !Object.keys(dag).length) return { nodes: [], width: 0, height: 0 };
      const stages = Object.keys(dag);
      // Ë®àÁÆóÊØèÂÄã stage ÁöÑÊ∑±Â∫¶ÔºàÊúÄÈï∑Ë∑ØÂæëÔºâ
      const depth = {};
      function getDepth(id) {
        if (depth[id] !== undefined) return depth[id];
        const deps = dag[id]?.deps || [];
        if (!deps.length) { depth[id] = 0; return 0; }
        const d = Math.max(...deps.map(getDepth)) + 1;
        depth[id] = d;
        return d;
      }
      stages.forEach(id => getDepth(id));

      // ÊåâÊ∑±Â∫¶ÂàÜÁµÑ
      const byDepth = {};
      stages.forEach(id => {
        const d = depth[id];
        if (!byDepth[d]) byDepth[d] = [];
        byDepth[d].push(id);
      });

      const NODE_W = 88, NODE_H = 72, H_GAP = 40, V_GAP = 20;
      const maxDepth = Math.max(...Object.keys(byDepth).map(Number));
      const totalW = (maxDepth + 1) * (NODE_W + H_GAP) - H_GAP;

      const nodes = [];
      Object.entries(byDepth).forEach(([d, ids]) => {
        const colH = ids.length * (NODE_H + V_GAP) - V_GAP;
        ids.forEach((id, i) => {
          const x = Number(d) * (NODE_W + H_GAP);
          const y = i * (NODE_H + V_GAP);
          nodes.push({ id, x, y, w: NODE_W, h: NODE_H, depth: Number(d) });
        });
      });

      const totalH = Math.max(...Object.values(byDepth).map(ids => ids.length)) * (NODE_H + V_GAP) - V_GAP;
      return { nodes, width: totalW, height: totalH };
    }

    // Ë®àÁÆó SVG ÈÄ£Á∑öË∑ØÂæëÔºàË≤ùËå≤Êõ≤Á∑öÔºâ
    function buildEdges(dag, nodes) {
      if (!dag || !nodes.length) return [];
      const nodeMap = Object.fromEntries(nodes.map(n => [n.id, n]));
      const edges = [];
      for (const [id, cfg] of Object.entries(dag)) {
        const target = nodeMap[id];
        if (!target) continue;
        for (const dep of (cfg?.deps || [])) {
          const source = nodeMap[dep];
          if (!source) continue;
          const x1 = source.x + source.w;
          const y1 = source.y + source.h / 2;
          const x2 = target.x;
          const y2 = target.y + target.h / 2;
          const cx = (x1 + x2) / 2;
          edges.push({ id: `${dep}->${id}`, path: `M${x1},${y1} C${cx},${y1} ${cx},${y2} ${x2},${y2}`, from: dep, to: id });
        }
      }
      return edges;
    }

    // ÂÅµÊ∏¨ phase ÂàÜÁµÑÔºàsuffixed stages: DEV:1, REVIEW:1 ‚Üí phase 1Ôºâ
    function detectPhases(dag) {
      if (!dag) return {};
      const phases = {};
      for (const id of Object.keys(dag)) {
        const m = id.match(/:(\d+)$/);
        if (m) {
          const n = m[1];
          if (!phases[n]) phases[n] = [];
          phases[n].push(id);
        }
      }
      return Object.keys(phases).length >= 2 ? phases : {};
    }

    // --- DAG ÊµÅÁ®ãÂúñÂÖÉ‰ª∂ ---
    function DagView({ state, registry }) {
      const [selected, setSelected] = useState(null);
      const dag = state?.dag || {};
      const stages = state?.stages || {};

      const { nodes, width, height } = useMemo(() => computeDagLayout(dag, 800), [dag]);
      const edges = useMemo(() => buildEdges(dag, nodes), [dag, nodes]);
      const phases = useMemo(() => detectPhases(dag), [dag]);

      if (!nodes.length) {
        return html`<div style="color:var(--subtext0);font-size:11px;padding:20px;text-align:center">ÁÑ° Pipeline DAG Ë≥áÊñô</div>`;
      }

      const PADDING = 24;
      const svgW = width + PADDING * 2;
      const svgH = height + PADDING * 2;

      // Âèñ stage ÁØÄÈªûÁöÑÁãÄÊÖãËâ≤ÂΩ©
      const edgeClass = (from, to) => {
        const fromStatus = getStageStatus(from, state);
        if (fromStatus === 'completed') return 'completed';
        if (fromStatus === 'active') return 'active';
        return 'pending';
      };

      // Âèñ stage metadataÔºàÊîØÊè¥ suffixed stageÔºâ
      const getStageMeta = (id) => {
        const base = id.split(':')[0];
        return registry?.stages?.[base] || { emoji: 'üìå', label: base, color: null };
      };

      const selectedStage = selected ? stages[selected] : null;
      const selectedMeta = selected ? getStageMeta(selected) : null;
      const selectedVerdict = selected ? getStageVerdict(selected, state) : null;
      const selectedSeverity = selected ? getStageSeverity(selected, state) : null;
      const selectedDur = selected ? getStageDuration(selected, state) : null;
      const selectedRetries = selected ? (state?.retries?.[selected] || 0) : 0;
      const selectedCrashes = selected ? (state?.crashes?.[selected] || 0) : 0;
      const selectedHistory = selected ? (state?.retryHistory?.[selected] || []) : [];

      return html`
        <div style="display:flex;flex-direction:column;gap:12px">
          <!-- Barrier ‰∏¶Ë°åÈÄ≤Â∫¶ÔºàËã•ÊúâÔºâ -->
          ${selected === null && html`<${BarrierDisplay} barrierState=${null} />`}

          <!-- DAG Ë¶ñÂúñ -->
          <div class="dag-container" style="min-height:${svgH + 20}px">
            <svg class="dag-svg" width=${svgW} height=${svgH} style="position:absolute;top:0;left:0">
              ${edges.map(e => html`
                <path key=${e.id}
                  class="dag-edge ${edgeClass(e.from, e.to)}"
                  d=${e.path}
                  transform="translate(${PADDING},${PADDING})"
                />
              `)}
            </svg>
            ${nodes.map(n => {
              const status = getStageStatus(n.id, state);
              const verdict = getStageVerdict(n.id, state);
              const severity = getStageSeverity(n.id, state);
              const meta = getStageMeta(n.id);
              const isSelected = selected === n.id;
              let statusText = '';
              if (status === 'completed') statusText = verdict || 'PASS';
              else if (status === 'failed') statusText = severity || verdict || 'FAIL';
              else if (status === 'active') statusText = 'ÈÄ≤Ë°å‰∏≠';
              else if (status === 'skipped') statusText = 'Ë∑≥ÈÅé';
              else statusText = 'Á≠âÂæÖ';

              return html`
                <div key=${n.id}
                  class="dag-node ${status} ${isSelected ? 'selected' : ''}"
                  style="left:${n.x + PADDING}px;top:${n.y + PADDING}px;width:${n.w}px;height:${n.h}px;"
                  onClick=${() => setSelected(isSelected ? null : n.id)}
                >
                  <span class="dag-emoji">${meta.emoji}</span>
                  <span class="dag-label">${n.id}</span>
                  <span class="dag-status">${statusText}</span>
                </div>
              `;
            })}
            <!-- Phase ÂàÜÁµÑÊ°Ü -->
            ${Object.entries(phases).map(([phaseN, phaseIds]) => {
              const phaseNodes = nodes.filter(n => phaseIds.includes(n.id));
              if (!phaseNodes.length) return null;
              const xs = phaseNodes.map(n => n.x + PADDING);
              const ys = phaseNodes.map(n => n.y + PADDING);
              const x2s = phaseNodes.map(n => n.x + n.w + PADDING);
              const y2s = phaseNodes.map(n => n.y + n.h + PADDING);
              const bx = Math.min(...xs) - 8;
              const by = Math.min(...ys) - 14;
              const bw = Math.max(...x2s) - bx + 8;
              const bh = Math.max(...y2s) - by + 8;
              return html`
                <div key=${'phase'+phaseN} class="dag-phase" style="left:${bx}px;top:${by}px;width:${bw}px;height:${bh}px">
                  <span class="dag-phase-title">Phase ${phaseN}</span>
                </div>
              `;
            })}
          </div>

          <!-- ÈªûÊìäÂ±ïÈñãË©≥ÊÉÖ -->
          ${selected && html`
            <div class="dag-detail">
              <h4>${selectedMeta?.emoji} ${selected} ‚Äî ${selectedMeta?.label}</h4>
              ${selectedVerdict ? html`
                <div class="dag-detail-row">
                  <span class="label">Verdict</span>
                  <span class="value" style="color:var(--${selectedVerdict === 'PASS' ? 'green' : 'red'})">${selectedVerdict}${selectedSeverity ? ' ('+selectedSeverity+')' : ''}</span>
                </div>
              ` : html`
                <div class="dag-detail-row"><span class="label">ÁãÄÊÖã</span><span class="value">${getStageStatus(selected, state)}</span></div>
              `}
              ${selectedDur !== null && html`
                <div class="dag-detail-row"><span class="label">ËÄóÊôÇ</span><span class="value">${fmtSec(selectedDur)}</span></div>
              `}
              ${selectedRetries > 0 && html`
                <div class="dag-detail-row"><span class="label">ÈáçË©¶</span><span class="value" style="color:var(--orange)">${selectedRetries} Ê¨°</span></div>
              `}
              ${selectedCrashes > 0 && html`
                <div class="dag-detail-row"><span class="label">Crash</span><span class="value" style="color:var(--red)">${selectedCrashes} Ê¨°</span></div>
              `}
              ${selectedHistory.length > 0 && html`
                <div style="margin-top:6px;font-size:9px;color:var(--subtext0)">ÈáçË©¶Ê≠∑Âè≤</div>
                ${selectedHistory.map(h => html`
                  <div class="rh-round ${h.verdict?.toLowerCase()}">R${h.round}: ${h.verdict} <span style="opacity:0.6">${h.severity || ''}</span></div>
                `)}
              `}
            </div>
          `}
        </div>
      `;
    }

    // --- Barrier È°ØÁ§∫ÂÖÉ‰ª∂ ---
    function BarrierDisplay({ barrierState }) {
      if (!barrierState || !Object.keys(barrierState.groups || {}).length) return null;
      return html`
        <div style="padding:8px 12px;background:var(--surface0);border-radius:8px;border:1px solid var(--surface1)">
          <div style="font-size:10px;color:var(--subtext0);margin-bottom:6px;text-transform:uppercase;letter-spacing:1px">Barrier ‰∏¶Ë°åÈÄ≤Â∫¶</div>
          ${Object.entries(barrierState.groups || {}).map(([group, g]) => html`
            <div key=${group} style="display:flex;align-items:center;gap:10px;font-size:11px;margin-bottom:4px">
              <span style="color:var(--blue);min-width:80px">${group}</span>
              <span style="color:${g.resolved ? (Object.values(g.results || {}).some(r => r.verdict === 'FAIL') ? 'var(--red)' : 'var(--green)') : 'var(--yellow)'}">${g.completed.length}/${g.total}</span>
              <span style="color:var(--subtext0)">${g.siblings.map(st => g.completed.includes(st) ? (g.results?.[st]?.verdict === 'FAIL' ? '‚ùå' : '‚úÖ') : '‚è≥').join(' ')} ${g.siblings.join(' + ')}</span>
              ${g.resolved && html`<span style="font-size:9px;padding:1px 6px;border-radius:4px;background:${Object.values(g.results || {}).some(r => r.verdict === 'FAIL') ? 'var(--red)' : 'var(--green)'};color:var(--bg)">${g.next ? '‚Üí ' + g.next : 'ÂÆåÊàê'}</span>`}
              ${!g.resolved && html`<span style="font-size:9px;color:var(--yellow);animation:blink 1s infinite">Á≠âÂæÖ‰∏≠...</span>`}
            </div>
          `)}
        </div>
      `;
    }

    // --- Á∞°ÂåñÁâà Agent ÁãÄÊÖãÈù¢Êùø ---
    function AgentStatus({ state, tick, events, registry, alive, memory }) {
      const timers = useRef({});

      // Âæû registry ÂãïÊÖãÂª∫Á´ã agent Ê∏ÖÂñÆÔºà3 Áæ§ÁµÑÔºâ
      const systemAgents = [
        { id: 'main', name: 'Main Agent', emoji: 'üéØ', group: 'system' },
        { id: 'explore', name: 'Explore', emoji: 'üî≠', group: 'system' },
        { id: 'plan', name: 'Plan', emoji: 'üìê', group: 'system' },
      ];
      const pipelineAgents = registry?.stages
        ? Object.entries(registry.stages).map(([stageId, cfg]) => ({
            id: cfg.agent, name: cfg.agent, emoji: cfg.emoji, stage: stageId, group: 'pipeline', color: cfg.color,
          }))
        : [];
      const supportAgents = [
        { id: 'security-reviewer', name: 'security', emoji: 'üõ°Ô∏è', group: 'support' },
        { id: 'build-error-resolver', name: 'build-err', emoji: 'üîß', group: 'support' },
        { id: 'pipeline-architect', name: 'pipeline-architect', emoji: 'üìê', group: 'support' },
      ];
      const allAgents = [...systemAgents, ...pipelineAgents, ...supportAgents];

      // Pipeline ÊòØÂê¶Â∑≤ÂÆåÊàêÔºàÊâÄÊúâÁáàËôüÁÜÑÊªÖÁî®Ôºâ
      const pipelineDone = hasPipeline(state) && getPipelineProgress(state) >= 100 && !state?.pipelineActive && (state?.activeStages || []).length === 0;

      // ÂèñÂæóÊØèÂÄã agent ÁöÑÁ∞°ÂåñÁãÄÊÖã
      function getAgentStatus(agent) {
        // Pipeline ÂÆåÂÖ®ÁµêÊùü ‚Üí ÊâÄÊúâÁáàËôüÁÜÑÊªÖ
        if (pipelineDone) return { status: 'idle', label: '‚Äî', dur: null };

        // ‰∏ª agent
        if (agent.id === 'main') {
          if (alive === false) return { status: 'idle', label: '‚Äî', dur: null };
          const activeCount = getActiveStages(state).length;
          if (activeCount > 0) return { status: 'delegating', label: 'ÂßîÊ¥æ‰∏≠', dur: null };
          if (state?.pipelineActive) return { status: 'running', label: 'Âü∑Ë°å‰∏≠', dur: null };
          return { status: 'idle', label: '‚Äî', dur: null };
        }
        // Pipeline stage agents ‚Äî ÂêåÊôÇÊ™¢Êü• DAG stages Âíå activeStages
        if (agent.stage) {
          // ÂÑ™ÂÖàÊ™¢Êü• activeStagesÔºàdelegation-tracker ËøΩËπ§ÁöÑÂØ¶ÈöõÈÅãË°å agentÔºâ
          const isInActiveStages = (state?.activeStages || []).some(s => s === agent.stage || s.split(':')[0] === agent.stage);
          if (isInActiveStages) return { status: 'running', label: 'Âü∑Ë°å‰∏≠', dur: null };

          const dagKeys = Object.keys(state?.dag || {});
          const matchedStages = dagKeys.filter(k => k === agent.stage || k.split(':')[0] === agent.stage);
          for (const sid of matchedStages) {
            const status = getStageStatus(sid, state);
            if (status === 'active') return { status: 'running', label: 'Âü∑Ë°å‰∏≠', dur: null };
          }
          // ÊâæÂ∑≤ÂÆåÊàêÁöÑÊúÄËøë‰∏ÄÂÄã
          const completedStages = matchedStages.filter(k => getStageStatus(k, state) === 'completed' || getStageStatus(k, state) === 'failed');
          if (completedStages.length > 0) {
            const last = completedStages[completedStages.length - 1];
            const verdict = getStageVerdict(last, state);
            const dur = getStageDuration(last, state);
            if (verdict === 'FAIL') return { status: 'error', label: getStageSeverity(last, state) || 'FAIL', dur };
            return { status: 'pass', label: verdict || 'PASS', dur };
          }
          // Âú® DAG ‰∏≠‰ΩÜÈÇÑÊ≤íÈñãÂßã ‚Üí Á≠âÂæÖÔºõ‰∏çÂú® DAG ‰∏≠ ‚Üí ÈñíÁΩÆ
          if (matchedStages.length > 0) return { status: 'idle', label: 'Á≠âÂæÖ', dur: null };
          return { status: 'idle', label: '‚Äî', dur: null };
        }
        // Âæû‰∫ã‰ª∂‰∏≤ÊµÅÂÅµÊ∏¨ support/system agentsÔºàÂÉÖ pipeline Â≠òÂú®ÊôÇÈ°ØÁ§∫Ôºâ
        if (events?.length && hasPipeline(state)) {
          const lastDel = events.find(e => e.eventType === 'delegation.start' && e.text?.includes(agent.id));
          if (lastDel) return { status: 'idle', label: 'ÂÆåÊàê', dur: null };
        }
        return { status: 'idle', label: '‚Äî', dur: null };
      }

      const enriched = allAgents.map(a => {
        const s = getAgentStatus(a);
        // running ÁãÄÊÖãÊôÇÔºåÂæû timeline events ÂèñÊúÄÊñ∞ delegation.start ÊèèËø∞‰ΩúÁÇ∫ label
        if (s.status === 'running' && events?.length) {
          const lastActivity = [...events].reverse().find(e =>
            e.eventType === 'delegation.start' &&
            e.text?.toLowerCase().includes(a.id)
          );
          if (lastActivity?.text) {
            const t = lastActivity.text;
            s.label = t.length > 20 ? t.slice(0, 20) + '‚Ä¶' : t;
          }
        }
        return { ...a, ...s };
      });
      // ÂêåÊ≠•Ë®àÊôÇÂô®
      enriched.forEach(a => {
        if (a.status === 'running' && !timers.current[a.id]) timers.current[a.id] = Date.now();
        else if (a.status !== 'running') delete timers.current[a.id];
      });

      const activeCount = enriched.filter(a => a.status === 'running' || a.status === 'delegating').length;
      const completedCount = enriched.filter(a => a.status === 'completed').length;

      const groups = [
        { label: 'Á≥ªÁµ±', agents: enriched.filter(a => a.group === 'system') },
        { label: 'PIPELINE', agents: enriched.filter(a => a.group === 'pipeline') },
        { label: 'ËºîÂä©', agents: enriched.filter(a => a.group === 'support') },
      ];

      const renderRow = (a) => {
        let durText = '';
        if ((a.status === 'running' || a.status === 'delegating') && timers.current[a.id]) {
          durText = fmtSec(Math.round((Date.now() - timers.current[a.id]) / 1000));
        } else if (a.dur) {
          durText = fmtSec(a.dur);
        }
        return html`
          <div key=${a.id + (a.stage || '')} class="agent-row">
            <span class="al ${a.status === 'running' || a.status === 'delegating' ? a.status : a.status === 'completed' ? 'completed' : a.status === 'error' ? 'error' : a.status === 'pass' ? 'pass' : 'idle'}"></span>
            <span class="agent-name" style="${(a.status === 'running' || a.status === 'delegating') && a.color ? 'color:' + a.color : a.status === 'pass' ? 'color:var(--green)' : a.status === 'error' ? 'color:var(--red)' : ''}">${a.emoji} ${a.name}</span>
            <span class="agent-status-text ${a.status}">${a.label}</span>
            <span class="agent-dur">${durText}</span>
          </div>
        `;
      };

      return html`
        <div class="agent-panel">
          <div class="agent-panel-hdr">
            <h3>ü§ñ Agents Áï∂ÂâçÁãÄÊÖã</h3>
            <div class="agent-panel-stats">
              <span class="agent-panel-stat">Ê¥ªË∫ç <span class="num">${activeCount}</span></span>
            </div>
          </div>
          ${groups.map((g, gi) => g.agents.length > 0 && html`
            <div key=${g.label}>
              ${gi > 0 && html`<div class="agent-sep"></div>`}
              <div class="agent-group-label">${g.label}</div>
              ${g.agents.map(renderRow)}
            </div>
          `)}
        </div>
      `;
    }

    // --- MCP Áµ±Ë®àÈù¢Êùø ---
    function MCPStats({ events }) {
      const stats = useMemo(() => {
        const servers = {};
        for (const ev of events) {
          if (!ev.text) continue;
          const m = ev.text.match(/^([a-z][a-z0-9_-]*):/i);
          if (!m) continue;
          const server = m[1];
          if (!servers[server]) servers[server] = { count: 0, methods: {} };
          servers[server].count++;
          const method = ev.text.slice(server.length + 1).split(' ')[0];
          if (method) servers[server].methods[method] = (servers[server].methods[method] || 0) + 1;
        }
        return Object.entries(servers).sort((a, b) => b[1].count - a[1].count);
      }, [events]);
      if (stats.length === 0) return null;
      const total = stats.reduce((sum, [, s]) => sum + s.count, 0);
      const maxCount = stats[0]?.[1]?.count || 1;
      return html`
        <div class="mcp-stats">
          <h3>üîå MCP Ê¥ªÂãï<span class="mcp-total">${total} calls</span></h3>
          ${stats.map(([server, s]) => {
            const topMethods = Object.entries(s.methods).sort((a, b) => b[1] - a[1]).slice(0, 4).map(([m]) => m).join(', ');
            return html`
              <div key=${server} class="mcp-row">
                <span class="mcp-server">${server}</span>
                <span class="mcp-count">${s.count}</span>
                <div class="mcp-bar"><div class="mcp-fill" style="width:${(s.count / maxCount * 100)}%"></div></div>
                <span class="mcp-methods">${topMethods}</span>
              </div>
            `;
          })}
        </div>
      `;
    }

    // --- Áµ±Ë®àÂç°ÁâáÔºà8 ÂºµÔºâ---
    function StatsCards({ state, events, tick, metrics }) {
      const mt = metrics || {};
      const contextPct = mt.contextPct || 0;
      const transcriptSize = mt.transcriptSize || 0;
      const toolCallCount = mt.toolCallCount || 0;
      // Âæû events Ë®àÁÆó compact Ê¨°Êï∏ÔºàËàá server metrics ‰∫íË£úÔºåÂèñËºÉÂ§ßÂÄºÁ¢∫‰øù‰∏çÊºèË®àÔºâ
      const compactCountFromEvents = useMemo(() =>
        events.filter(e => e.eventType === 'compact.executed').length,
        [events]
      );
      // ÂÑ™ÂÖà‰ΩøÁî® server Á´ØÁõ¥Êé•Âæû timeline JSONL Ë®àÁÆóÁöÑ compactCountÔºàWS replay ÂæåËºÉÊ∫ñÁ¢∫ÔºâÔºå
      // ÂèñÂÖ©ËÄÖËºÉÂ§ßÂÄº‰ª•Èò≤Ê≠¢Ë®àÊï∏Ê≠∏Èõ∂
      const compactCount = Math.max(mt.compactCount || 0, compactCountFromEvents);
      const guardCount = useMemo(() =>
        events.filter(e => e.eventType === 'tool.blocked').length,
        [events]
      );
      const crashCount = useMemo(() =>
        Object.values(state?.crashes || {}).reduce((a, b) => a + (b || 0), 0),
        [state]
      );
      const retryCount = useMemo(() =>
        Object.values(state?.retries || {}).reduce((a, b) => a + (b || 0), 0),
        [state]
      );
      const delegateCount = useMemo(() =>
        events.filter(e => e.eventType === 'delegation.start').length,
        [events]
      );
      const startedAt = state?.classification?.classifiedAt || state?.meta?.lastTransition || mt.sessionStartedAt;
      const sessionDur = startedAt ? fmtDuration(startedAt) : '‚Äî';

      const cards = [
        { key: 'context', emoji: 'üìä', label: 'Context ‰ΩøÁî®Áéá', value: contextPct + '%', sub: toolCallCount + ' / 200 tool calls',
          level: contextPct > 80 ? 'danger' : contextPct > 50 ? 'warn' : '',
          hint: contextPct > 80 ? 'Âª∫Ë≠∞ /compact Â£ìÁ∏Æ' : contextPct > 50 ? 'context ÂÅèÈ´ò' : null,
          tip: 'Tool call Ê¨°Êï∏‰ΩîÈñæÂÄºÊØî‰æãÔºåÂèçÊò† context ‰ΩøÁî®Á®ãÂ∫¶' },
        { key: 'filesize', emoji: 'üíæ', label: 'Session Â§ßÂ∞è', value: fmtSize(transcriptSize), sub: 'transcript Ê™îÊ°à',
          level: transcriptSize > 50*1024*1024 ? 'danger' : transcriptSize > 20*1024*1024 ? 'warn' : '',
          hint: transcriptSize > 50*1024*1024 ? 'Âª∫Ë≠∞ÈáçÈñã session' : transcriptSize > 20*1024*1024 ? 'session ËºÉÂ§ß' : null,
          tip: 'Session Â∞çË©±Ë®òÈåÑÊ™îÊ°àÂ§ßÂ∞èÔºåÈÅéÂ§ßÊôÇÂª∫Ë≠∞ÈñãÊñ∞ session' },
        { key: 'crash', emoji: 'üí•', label: 'Crash', value: '' + crashCount, sub: 'agent crash Ê¨°Êï∏',
          level: crashCount > 2 ? 'danger' : crashCount > 0 ? 'warn' : '',
          hint: crashCount > 2 ? 'È†ªÁπÅ crashÔºåÊ™¢Êü•Á©©ÂÆöÊÄß' : null,
          tip: 'Agent ÈùûÊ≠£Â∏∏‰∏≠Êñ∑ÁöÑÊ¨°Êï∏ÔºåÁ≥ªÁµ±ÊúÉËá™ÂãïÂõûÊî∂ÈáçË©¶' },
        { key: 'guard', emoji: 'üõ°Ô∏è', label: 'Guard ÊîîÊà™', value: '' + guardCount, sub: 'pipeline-guard ÈòªÊìã',
          level: guardCount > 10 ? 'warn' : '',
          hint: guardCount > 10 ? 'ÊèêÁ§∫Ë©ûÂèØËÉΩÈúÄË¶ÅÂÑ™Âåñ' : null,
          tip: 'Pipeline Ê®°Âºè‰∏ãÂØ´ÂÖ•Ë¢´ÊîîÊà™Ê¨°Êï∏ÔºåÈÅéÂ§ö‰ª£Ë°®ÊèêÁ§∫Ë©ûÂºïÂ∞é‰∏çË∂≥' },
        { key: 'compact', emoji: 'üì¶', label: 'Compact', value: '' + compactCount, sub: 'context Â£ìÁ∏ÆÊ¨°Êï∏',
          level: compactCount > 5 ? 'warn' : '',
          hint: compactCount > 5 ? 'È†ªÁπÅÂ£ìÁ∏ÆÔºåËÄÉÊÖÆÈáçÈñã' : null,
          tip: 'Â£ìÁ∏Æ context window ÁöÑÊ¨°Êï∏ÔºåÊØèÊ¨°Â£ìÁ∏ÆÊúÉÈÅ∫Â§±ÈÉ®ÂàÜ‰∏ä‰∏ãÊñá' },
        { key: 'retry', emoji: 'üîÅ', label: 'Retry ÂõûÈÄÄ', value: '' + retryCount, sub: 'ÂêÑ stage ÈáçË©¶Á∏ΩÂíå',
          level: retryCount > 3 ? 'warn' : '',
          hint: retryCount > 3 ? 'ÂìÅË≥™ÈñÄÂ§öÊ¨°ÂõûÈÄÄ' : null,
          tip: 'ÂìÅË≥™ stage FAIL Ëß∏Áôº DEV ÂõûÈÄÄÁöÑÊ¨°Êï∏' },
        { key: 'delegate', emoji: 'ü§ñ', label: 'ÂßîÊ¥æÊ¨°Êï∏', value: '' + delegateCount, sub: 'sub-agent ÂßîÊ¥æ',
          level: '', hint: null,
          tip: 'Sub-agent ÂßîÊ¥æÁöÑÁ∏ΩÊ¨°Êï∏ÔºåÂèçÊò† pipeline Âü∑Ë°åÂØÜÂ∫¶' },
        { key: 'duration', emoji: '‚è±', label: 'Session ÊôÇÈï∑', value: sessionDur, sub: startedAt ? new Date(startedAt).toLocaleTimeString('zh-TW', { hour12: false }) : 'Êú™ÈñãÂßã',
          level: '', hint: null,
          tip: 'Âæû session ÈñãÂßãÂà∞ÁèæÂú®ÁöÑÁ∂ìÈÅéÊôÇÈñì' },
      ];

      return html`
        <div class="stats-grid">
          ${cards.map(c => html`
            <div key=${c.key} class="stat-card ${c.level}" data-tip=${c.tip}>
              <span class="stat-label">${c.emoji} ${c.label}</span>
              <span class="stat-value">${c.value}</span>
              <span class="stat-sub">${c.sub}</span>
              ${c.hint && html`<span class="stat-hint ${c.level}">${c.hint}</span>`}
            </div>
          `)}
        </div>
      `;
    }

    // --- ÂãïÊÖã Pipeline ÈÄ≤Â∫¶Ê¢ù ---
    function PipelineProgressBar({ state, registry }) {
      if (!hasPipeline(state)) return null;
      const dag = state.dag || {};
      const dagKeys = Object.keys(dag);
      const progress = getPipelineProgress(state);
      const isComp = progress === 100;

      return html`
        <div class="pipeline-progress">
          <h3 style="display:flex;align-items:center;justify-content:space-between">
            <span>üìä Pipeline ÈÄ≤Â∫¶</span>
            <span style="font-size:12px;color:${isComp ? 'var(--green)' : 'var(--blue)'};font-weight:700">${progress}%</span>
          </h3>
          <div class="pipeline-stages-bar">
            ${dagKeys.map(id => {
              const status = getStageStatus(id, state);
              const stageBase = id.split(':')[0];
              const meta = registry?.stages?.[stageBase];
              return html`
                <div key=${id} class="ps-block">
                  <span class="ps-label">${meta?.emoji || ''} ${id}</span>
                  <div class="ps-bar ${status}"></div>
                </div>
              `;
            })}
          </div>
        </div>
      `;
    }

    // --- Confetti ---
    const CONFETTI_COLORS = ['#a6e3a1', '#89b4fa', '#f9e2af', '#f5c2e7', '#cba6f7', '#89dceb', '#fab387', '#f38ba8'];
    function Confetti() {
      const pieces = useMemo(() => Array.from({ length: 60 }, (_, i) => ({
        left: Math.random() * 100, delay: Math.random() * 1.5, dur: 2.5 + Math.random() * 2,
        color: CONFETTI_COLORS[i % CONFETTI_COLORS.length], w: 5 + Math.random() * 7, h: 3 + Math.random() * 5,
      })), []);
      return html`<div class="confetti-wrap">
        ${pieces.map((p, i) => html`<div key=${i} class="confetti-piece" style="left:${p.left}%;--delay:${p.delay}s;--dur:${p.dur}s;background:${p.color};width:${p.w}px;height:${p.h}px"></div>`)}
      </div>`;
    }

    // --- Â†±ÂëäÂ∞éÂá∫ ---
    function exportReport(state, sessionId, events, format, registry) {
      if (!state) return;
      const dag = state.dag || {};
      const stages = Object.keys(dag).map(id => {
        const status = getStageStatus(id, state);
        const verdict = getStageVerdict(id, state);
        const meta = registry?.stages?.[id.split(':')[0]];
        return { stage: id, agent: meta?.agent || '‚Äî', label: meta?.label || id, status, verdict: verdict || (status === 'skipped' ? 'SKIP' : '‚Äî'), retries: state.retries?.[id] || 0 };
      });
      const pid = state.classification?.pipelineId;
      const pLabel = (registry?.pipelines?.[pid]?.label) || pid || '‚Äî';

      if (format === 'json') {
        const report = { sessionId, pipelineId: pid, progress: getPipelineProgress(state) + '%', stages, timeline: events.slice(0, 50).map(e => ({ time: e.time, text: e.text, type: e.type })), exportedAt: new Date().toISOString() };
        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `pipeline-${sessionId?.slice(0, 8) || 'report'}.json`; a.click();
      } else {
        const lines = [`# Pipeline Report\n`, `- **Session**: ${sessionId}`, `- **Pipeline**: ${pLabel}`, `- **Progress**: ${getPipelineProgress(state)}%`, `- **Exported**: ${new Date().toISOString()}\n`, `## Stages\n`, `| Stage | Agent | Verdict | Retries |`, `|-------|-------|---------|---------|`];
        for (const st of stages) lines.push(`| ${st.stage} | ${st.agent} | ${st.verdict} | ${st.retries} |`);
        if (events.length) { lines.push(`\n## Timeline\n`); for (const ev of events.slice(0, 30)) lines.push(`- \`${ev.time}\` ${ev.text}`); }
        const blob = new Blob([lines.join('\n')], { type: 'text/markdown' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `pipeline-${sessionId?.slice(0, 8) || 'report'}.md`; a.click();
      }
    }

    // --- App ---
    function App() {
      const [sessions, setSessions] = useState({});
      const [active, setActive] = useState(null);
      const [conn, setConn] = useState(false);
      const [sideOpen, setSideOpen] = useState(true);
      const [tlOpen, setTlOpen] = useState(true);
      const [fullscreen, setFullscreen] = useState(false);
      const [toast, setToast] = useState(null);
      const [tick, setTick] = useState(0);
      const [showConfetti, setShowConfetti] = useState(false);
      const [zoom, setZoom] = useState(100);
      const [timelineEvents, setTimelineEvents] = useState({});
      const [alive, setAlive] = useState({});
      const [barrierStates, setBarrierStates] = useState({});
      const [memory, setMemory] = useState(null);
      const [tlFilter, setTlFilter] = useState(0);
      const [tlTab, setTlTab] = useState('all');
      const [mainTab, setMainTab] = useState('dashboard');
      const [registry, setRegistry] = useState(null);
      const [sessionMetrics, setSessionMetrics] = useState({});
      const [showStale, setShowStale] = useState(false);
      const confettiShown = useRef(new Set());

      // ËºâÂÖ• registry
      useEffect(() => {
        fetch('/api/registry')
          .then(r => r.json())
          .then(setRegistry)
          .catch(() => {});
      }, []);

      // registry typeLabel ÂáΩÂºè
      const typeLabel = (t) => {
        if (!registry) return t || '‚Äî';
        const p = registry.pipelines?.[t];
        return p?.label || t || '‚Äî';
      };

      // Âêà‰Ωµ alive ÁãÄÊÖã
      const mergedSessions = useMemo(() => {
        const out = {};
        for (const [id, s] of Object.entries(sessions)) {
          out[id] = alive[id] ? { ...s, _alive: true } : s;
        }
        for (const id of Object.keys(alive)) {
          if (alive[id] && !out[id]) out[id] = { _alive: true, _heartbeatOnly: true };
        }
        return out;
      }, [sessions, alive]);

      // ÂàÜÁµÑÔºàÊ¥ªË∫çÂÑ™ÂÖà ‚Üí ÊúÄËøëÊ¥ªÂãïÔºâËá™ÂãïÊéíÂ∫è
      const { liveSessions, doneSessions, staleSessions } = useMemo(() => {
        const live = [], done = [], stale = [];
        for (const [id, s] of Object.entries(mergedSessions)) {
          const cat = sessionCategory(s);
          if (cat === 'live' || cat === 'active') live.push([id, s]);
          else if (cat === 'done') done.push([id, s]);
          else stale.push([id, s]);
        }
        // Ê¥ªË∫çÂÑ™ÂÖà ‚Üí ÊúÄËøëÊ¥ªÂãïÊôÇÈñìÊéíÂ∫è
        const byRecent = (a, b) => {
          const aAlive = a[1]._alive ? 1 : 0, bAlive = b[1]._alive ? 1 : 0;
          if (aAlive !== bAlive) return bAlive - aAlive;
          return new Date(b[1].meta?.lastTransition || 0) - new Date(a[1].meta?.lastTransition || 0);
        };
        live.sort(byRecent);
        done.sort((a, b) => new Date(b[1].meta?.lastTransition || 0) - new Date(a[1].meta?.lastTransition || 0));
        stale.sort((a, b) => new Date(b[1].meta?.lastTransition || 0) - new Date(a[1].meta?.lastTransition || 0));
        return { liveSessions: live, doneSessions: done, staleSessions: stale };
      }, [mergedSessions]);

      const s = active ? mergedSessions[active] : null;
      const activeBarrier = active ? barrierStates[active] : null;
      const progress = s ? getPipelineProgress(s) : 0;
      const isComplete = progress === 100 && hasPipeline(s);
      const selectSession = id => { setActive(id); };

      const tlAll = timelineEvents[active] || [];
      const tlFiltered = useMemo(() => {
        let list = tlAll;
        if (tlTab !== 'all') list = list.filter(ev => ev.cat === tlTab);
        if (tlFilter !== 0) { const cutoff = Date.now() - tlFilter * 60000; list = list.filter(ev => ev.ts && ev.ts >= cutoff); }
        return list;
      }, [tlAll, tlFilter, tlTab, tick]);

      // ÊØèÁßí tick
      useEffect(() => { const id = setInterval(() => setTick(t => t + 1), 1000); return () => clearInterval(id); }, []);

      // Confetti Ëß∏Áôº
      useEffect(() => {
        if (isComplete && active && !confettiShown.current.has(active)) {
          confettiShown.current.add(active);
          setShowConfetti(true);
          setTimeout(() => setShowConfetti(false), 4000);
        }
      }, [isComplete, active]);

      // WebSocketÔºàÊåáÊï∏ÈÄÄÈÅø + ÂøÉË∑≥Ôºâ
      useEffect(() => {
        let ws, rt, hb, retries = 0;
        function connect() {
          const p = location.protocol === 'https:' ? 'wss' : 'ws';
          ws = new WebSocket(`${p}://${location.host}/ws`);
          ws.onopen = () => { setConn(true); retries = 0; clearInterval(hb); hb = setInterval(() => { try { ws.send('ping'); } catch {} }, 25000); };
          ws.onclose = () => { setConn(false); clearInterval(hb); rt = setTimeout(connect, Math.min(300 * Math.pow(2, retries++), 5000)); };
          ws.onerror = () => {};
          ws.onmessage = e => {
            if (e.data === 'pong') return;
            const m = JSON.parse(e.data);
            // Áõ¥Êé•Â≠òÂéüÂßã v4 stateÔºà‰∏ç adaptStateÔºâ
            if (m.sessions) setSessions(m.sessions);
            if (m.alive) setAlive(prev => ({ ...prev, ...m.alive }));
            if (m.memory) setMemory(m.memory);
            if (m.metrics) setSessionMetrics(prev => ({ ...prev, ...m.metrics }));
            if (m.type === 'timeline' && m.sessionId && m.event) {
              setTimelineEvents(prev => {
                const list = prev[m.sessionId] || [];
                return { ...prev, [m.sessionId]: [m.event, ...list].slice(0, 200) };
              });
            }
            if (m.type === 'barrier' && m.sessionId) {
              setBarrierStates(prev => ({ ...prev, [m.sessionId]: m.barrierState }));
            }
          };
        }
        connect();
        return () => { ws?.close(); clearTimeout(rt); clearInterval(hb); };
      }, []);

      // Á∏ÆÊîæÊéßÂà∂
      useEffect(() => {
        function onZoom(e) {
          if (!(e.metaKey || e.ctrlKey)) return;
          if (e.key === '=' || e.key === '+') { e.preventDefault(); e.stopPropagation(); setZoom(z => Math.min(200, z + 10)); return; }
          if (e.key === '-') { e.preventDefault(); e.stopPropagation(); setZoom(z => Math.max(50, z - 10)); return; }
          if (e.key === '0') { e.preventDefault(); e.stopPropagation(); setZoom(100); return; }
        }
        window.addEventListener('keydown', onZoom, true);
        return () => window.removeEventListener('keydown', onZoom, true);
      }, []);

      const zoomStyle = useMemo(() => {
        if (zoom === 100) return '';
        const sc = zoom / 100;
        return `transform:scale(${sc});transform-origin:0 0;width:${100/sc}vw;height:${100/sc}vh;`;
      }, [zoom]);

      // ÈçµÁõ§Âø´Êç∑Èçµ
      useEffect(() => {
        function onKey(e) {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
          if (e.metaKey || e.ctrlKey) return;
          const sids = [...liveSessions, ...doneSessions, ...staleSessions].map(([id]) => id);
          const idx = sids.indexOf(active);
          switch(e.key) {
            case 'ArrowUp': case 'k': e.preventDefault(); if (idx > 0) selectSession(sids[idx - 1]); break;
            case 'ArrowDown': case 'j': e.preventDefault(); if (idx < sids.length - 1) selectSession(sids[idx + 1]); break;
            case 's': case 'S': setSideOpen(p => !p); showToast('S ‚Äî ÂÅ¥ÈÇäÊ¨ÑÂàáÊèõ'); break;
            case 'f': case 'F': setFullscreen(p => !p); showToast('F ‚Äî ÂÖ®Ëû¢ÂπïÂàáÊèõ'); break;
            case 't': case 'T': setMainTab('timeline'); showToast('T ‚Äî Timeline'); break;
            case '1': setMainTab('dashboard'); showToast('1 ‚Äî Dashboard'); break;
            case '2': setMainTab('pipeline'); showToast('2 ‚Äî Pipeline'); break;
            case '3': setMainTab('timeline'); showToast('3 ‚Äî Timeline'); break;
            case '?': showToast('1/2/3 Tab ¬∑ ‚Üë‚Üì ÂàáÊèõ ¬∑ S ÂÅ¥ÈÇä ¬∑ F ÂÖ®Ëû¢Âπï ¬∑ E Â∞éÂá∫ ¬∑ ‚åò¬± Á∏ÆÊîæ'); break;
            case 'e': case 'E': if (s) { exportReport(s, active, tlAll, 'md', registry); showToast('E ‚Äî Â∞éÂá∫ Markdown'); } break;
          }
        }
        window.addEventListener('keydown', onKey);
        return () => window.removeEventListener('keydown', onKey);
      }, [active, liveSessions, doneSessions, staleSessions, s, tlAll, registry]);

      function showToast(msg) { setToast(msg); setTimeout(() => setToast(null), 2000); }

      // Ëá™ÂãïÈÅ∏Êìá + Ë∑üÈö®Ê¥ªË∫ç session
      useEffect(() => {
        const sids = Object.keys(mergedSessions);
        if (!sids.length) return;
        const liveSid = liveSessions.find(([, ss]) => ss._alive || isLive(ss))?.[0];
        if (liveSid && liveSid !== active) { selectSession(liveSid); return; }
        if (!active || !mergedSessions[active]) {
          setActive(liveSessions[0]?.[0] || doneSessions[0]?.[0] || sids[sids.length - 1]);
        }
      }, [mergedSessions, liveSessions]);

      return html`
        <div class="layout ${sideOpen && !fullscreen ? '' : fullscreen ? 'fullscreen' : 'collapsed'}" style="${zoomStyle}">
          ${showConfetti && html`<${Confetti} />`}
          ${toast && html`<div class="kbd-toast">${toast}</div>`}

          <!-- Sidebar -->
          <div class="sidebar">
            <div class="sb-top">
              <button class="sb-toggle" onClick=${() => setSideOpen(!sideOpen)}>${sideOpen ? '‚óÄ' : '‚ñ∂'}</button>
            </div>
            <div class="sb-body">
              ${liveSessions.length > 0 && html`
                <div class="group-hdr"><h2>ÈÄ≤Ë°å‰∏≠</h2><span class="count">${liveSessions.length}</span></div>
                ${liveSessions.map(([id, ss]) => {
                  const cat = sessionCategory(ss);
                  const p = getPipelineProgress(ss);
                  const stage = currentStageName(ss, registry);
                  return html`
                    <div key=${id} class="sc ${cat} ${id === active ? 'selected' : ''}" data-pct="${p}%" onClick=${() => selectSession(id)} title=${id}>
                      <button class="x" onClick=${e => { e.stopPropagation(); deleteSession(id); }}>√ó</button>
                      <div class="sc-title">
                        ${isLive(ss) && html`<span class="live-dot"></span>`}
                        ${sessionName(ss, registry)}
                      </div>
                      <div class="sc-sub">${sid(id)} ¬∑ ${elapsed(ss.meta?.lastTransition || ss.classification?.classifiedAt)}</div>
                      ${stage && html`<div class="sc-meta">${stage}${p > 0 ? ` ¬∑ ${p}%` : ''}</div>`}
                      ${hasPipeline(ss) && html`<div class="sc-bar"><div class="sc-bar-fill ${p >= 100 ? 'complete' : ''}" style="width:${p}%"></div></div>`}
                    </div>
                  `;
                })}
              `}

              ${doneSessions.length > 0 && html`
                <div class="group-sep">
                  <span>Â∑≤ÂÆåÊàê (${doneSessions.length})</span>
                  <button class="cleanup-btn" onClick=${() => doneSessions.forEach(([id]) => deleteSession(id))}>Ê∏ÖÁêÜ</button>
                </div>
                ${doneSessions.map(([id, ss]) => html`
                  <div key=${id} class="sc done ${id === active ? 'selected' : ''}" data-pct="‚úÖ" onClick=${() => selectSession(id)} title=${id}>
                    <button class="x" onClick=${e => { e.stopPropagation(); deleteSession(id); }}>√ó</button>
                    <div class="sc-title">‚úÖ ${sessionName(ss, registry)}</div>
                    <div class="sc-sub">${sid(id)} ¬∑ ${elapsed(ss.meta?.lastTransition)}</div>
                  </div>
                `)}
              `}

              ${staleSessions.length > 0 && html`
                <div class="stale-toggle" onClick=${() => setShowStale(p => !p)}>
                  <span>${showStale ? '‚ñæ' : '‚ñ∏'}</span>
                  <span>ÈÅéÊúü (${staleSessions.length})</span>
                  <button class="cleanup-btn" style="margin-left:auto" onClick=${e => { e.stopPropagation(); cleanupStale(); }}>Ê∏ÖÁêÜ</button>
                </div>
                ${showStale && staleSessions.map(([id, ss]) => html`
                  <div key=${id} class="sc stale ${id === active ? 'selected' : ''}" data-pct="‚Äî" onClick=${() => selectSession(id)} title=${id}>
                    <button class="x" onClick=${e => { e.stopPropagation(); deleteSession(id); }}>√ó</button>
                    <div class="sc-title">${sessionName(ss, registry)}</div>
                    <div class="sc-sub">${sid(id)} ¬∑ ${elapsed(ss.meta?.lastTransition)} Ââç</div>
                  </div>
                `)}
              `}

              ${!Object.keys(mergedSessions).length && html`<div style="color:var(--subtext0);font-size:11px;padding:8px">ÁÑ°Ê¥ªË∫ç session</div>`}
            </div>
          </div>

          <!-- Main -->
          <div class="main">
            ${s ? html`
              <h1>
                üéØ Pipeline ‚Äî ${sid(active)}
                ${isComplete && html`<span style="margin-left:4px">üéâ</span>`}
                <div class="toolbar">
                  <button class="tool-btn ${fullscreen ? 'active' : ''}" onClick=${() => setFullscreen(!fullscreen)} title="ÂÖ®Ëû¢Âπï (F)">${fullscreen ? '‚ä°' : '‚äû'} ÂÖ®Ëû¢Âπï</button>
                  <div class="toolbar-sep"></div>
                  <button class="tool-btn" onClick=${() => exportReport(s, active, tlAll, 'md', registry)} title="Â∞éÂá∫ Markdown (E)">üìÑ MD</button>
                  <button class="tool-btn" onClick=${() => exportReport(s, active, tlAll, 'json', registry)} title="Â∞éÂá∫ JSON">{ } JSON</button>
                  <div class="toolbar-sep"></div>
                  <button class="tool-btn" onClick=${() => setZoom(z => Math.max(50, z - 10))} title="Á∏ÆÂ∞è (‚åò-)">‚àí</button>
                  <button class="tool-btn" style="min-width:48px;justify-content:center;font-variant-numeric:tabular-nums" onClick=${() => setZoom(100)} title="ÈáçË®≠Á∏ÆÊîæ (‚åò0)">${zoom}%</button>
                  <button class="tool-btn" onClick=${() => setZoom(z => Math.min(200, z + 10))} title="ÊîæÂ§ß (‚åò+)">+</button>
                  <div class="toolbar-sep"></div>
                  <div class="conn-indicator"><span class="dot ${conn ? 'on' : 'off'}"></span><span>${conn ? 'Â∑≤ÈÄ£Á∑ö' : 'ÈÄ£Á∑ö‰∏≠‚Ä¶'}</span></div>
                </div>
              </h1>

              <!-- Main Tabs -->
              <div class="main-tabs">
                <button class="main-tab ${mainTab === 'dashboard' ? 'active' : ''}" onClick=${() => setMainTab('dashboard')}>üìä Dashboard</button>
                <button class="main-tab ${mainTab === 'pipeline' ? 'active' : ''}" onClick=${() => setMainTab('pipeline')}>üîÑ Pipeline</button>
                <button class="main-tab ${mainTab === 'timeline' ? 'active' : ''}" onClick=${() => setMainTab('timeline')}>üìã Timeline${tlAll.length ? html`<span class="tab-count">(${tlAll.length})</span>` : ''}</button>
              </div>

              <!-- Tab: Dashboard -->
              ${mainTab === 'dashboard' && html`
              <div class="dash-grid">
                <div class="dash-left">
                  <${AgentStatus} state=${s} tick=${tick} events=${tlAll} registry=${registry} alive=${active ? !!alive[active] : false} memory=${memory} />
                  <${MCPStats} events=${tlAll} />
                  <${StatsCards} state=${s} events=${tlAll} tick=${tick} metrics=${active ? sessionMetrics[active] : null} />
                  <${PipelineProgressBar} state=${s} registry=${registry} />
                  ${isComplete && html`
                    <div class="cards">
                      <div class="card">
                        <h3>üéâ ÂÆåÊàêÊëòË¶Å</h3>
                        <div class="row"><span class="label">Pipeline</span><span class="value">${typeLabel(s.classification?.pipelineId)}</span></div>
                        <div class="row"><span class="label">ÈÄ≤Â∫¶</span><span class="value" style="color:var(--green)">100% ÂÆåÊàê</span></div>
                        <div class="row"><span class="label">Á∏ΩÈáçË©¶</span><span class="value">${Object.values(s.retries || {}).reduce((a, b) => a + b, 0) || 'ÁÑ°'}</span></div>
                        <div class="row"><span class="label">ÊôÇÈï∑</span><span class="value">${elapsed(s.classification?.classifiedAt || s.meta?.lastTransition)}</span></div>
                      </div>
                      <div class="card">
                        <h3>‚è± ÂêÑÈöéÊÆµËÄóÊôÇ</h3>
                        ${Object.keys(s.dag || {}).map(id => {
                          const dur = getStageDuration(id, s);
                          const stageData = s.stages?.[id];
                          const meta = registry?.stages?.[id.split(':')[0]];
                          const verdict = getStageVerdict(id, s);
                          const status = getStageStatus(id, s);
                          let durText = '‚Äî';
                          if (dur) durText = fmtSec(dur);
                          else if (status === 'completed' && stageData?.verdict?._crashRecovered) durText = '‚ö° ÂõûÊî∂';
                          else if (status === 'completed') durText = '< 1s';
                          else if (status === 'skipped') durText = 'Ë∑≥ÈÅé';
                          else if (status === 'active') durText = 'ÈÄ≤Ë°å‰∏≠...';
                          const verdictColor = verdict === 'PASS' ? 'var(--green)' : verdict === 'FAIL' ? 'var(--red)' : '';
                          return html`<div key=${id} class="row"><span class="label">${meta?.emoji || ''} ${id}</span><span class="value" style="${verdictColor ? 'color:'+verdictColor : ''}">${durText}${verdict ? ' ¬∑ '+verdict : ''}</span></div>`;
                        })}
                      </div>
                    </div>
                  `}
                </div>
                <div class="dash-right">
                  <div class="mini-tl">
                    <div style="display:flex;align-items:center;justify-content:space-between">
                      <h4>üìã ÈáåÁ®ãÁ¢ë‰∫ã‰ª∂</h4>
                    </div>
                    <div class="tl-items-wrap">
                      ${(() => {
                        const MILESTONE_TYPES = ['delegation.start', 'stage.start', 'stage.complete', 'stage.retry', 'stage.crash-recovery', 'pipeline.complete', 'pipeline.incomplete', 'pipeline.cancelled', 'task.classified', 'ask.question', 'ask.answered', 'session.start'];
                        const milestones = tlAll.filter(ev => MILESTONE_TYPES.includes(ev.eventType));
                        return milestones.length ? milestones.map((ev, i) => html`
                          <div key=${i} class="tl-item ${ev.type}"><span class="time">${ev.time}</span><span class="msg">${ev.emoji} ${ev.text}</span></div>
                        `) : html`<div style="color:var(--subtext0);font-size:10px">Á≠âÂæÖ‰∫ã‰ª∂ÊµÅ‚Ä¶</div>`;
                      })()}
                    </div>
                  </div>
                </div>
              </div>
              `}

              <!-- Tab: PipelineÔºàDAG ÊµÅÁ®ãÂúñÔºâ -->
              ${mainTab === 'pipeline' && html`
                <${BarrierDisplay} barrierState=${activeBarrier} />
                <${DagView} state=${s} registry=${registry} />
              `}

              <!-- Tab: Timeline -->
              ${mainTab === 'timeline' && html`
              <div class="tl-full">
                <div class="tl-tabs">
                  ${[['all', 'ÂÖ®ÈÉ®'], ['agent', 'üîß Â∑•ÂÖ∑'], ['pipeline', 'üîÑ Pipeline'], ['quality', '‚úÖ ÂìÅË≥™'], ['task', 'üìã ‰ªªÂãô']].map(([v, label]) => html`
                    <button key=${v} class="tl-tab ${tlTab === v ? 'active' : ''}" onClick=${() => setTlTab(v)}>${label}</button>
                  `)}
                </div>
                <div class="tl-filter">
                  ${[[0, 'ÂÖ®ÈÉ®'], [10, '10m'], [30, '30m'], [60, '1h']].map(([v, label]) => html`
                    <button key=${v} class="tl-chip ${tlFilter === v ? 'active' : ''}" onClick=${() => setTlFilter(v)}>${label}</button>
                  `)}
                </div>
                <div class="tl-items">
                  ${tlFiltered.length ? tlFiltered.map((ev, i) => html`
                    <div key=${i} class="tl-item ${ev.type}"><span class="time">${ev.time}</span><span class="msg">${ev.emoji} ${ev.text}</span></div>
                  `) : html`<div style="color:var(--subtext0);font-size:11px;padding:6px 0">${(tlFilter || tlTab !== 'all') ? 'Ê≠§ÁØ©ÈÅ∏Ê¢ù‰ª∂‰∏ãÁÑ°‰∫ã‰ª∂' : 'Á≠âÂæÖ‰∫ã‰ª∂ÊµÅ‚Ä¶'}</div>`}
                </div>
              </div>
              `}
            ` : html`
              <div class="empty">
                <div style="position:absolute;top:12px;right:16px;display:flex;align-items:center;gap:8px">
                  <button class="tool-btn" onClick=${() => setZoom(z => Math.max(50, z - 10))}>‚àí</button>
                  <button class="tool-btn" style="min-width:48px;justify-content:center;font-variant-numeric:tabular-nums" onClick=${() => setZoom(100)}>${zoom}%</button>
                  <button class="tool-btn" onClick=${() => setZoom(z => Math.min(200, z + 10))}>+</button>
                  <div class="conn-indicator"><span class="dot ${conn ? 'on' : 'off'}"></span><span>${conn ? 'Â∑≤ÈÄ£Á∑ö' : 'ÈÄ£Á∑ö‰∏≠‚Ä¶'}</span></div>
                </div>
                <div class="icon">üéØ</div>
                <div style="font-size:18px;font-weight:600">Vibe Pipeline Dashboard</div>
                <div class="hint">
                  ÁÑ°Ê¥ªË∫çÁöÑ pipeline session<br/><br/>
                  ‰ΩøÁî® Claude Code + vibe plugin ÈñãÂßã‰ªªÂãô<br/>
                  Pipeline ÊúÉËá™ÂãïÈ°ØÁ§∫Âú®Ê≠§
                </div>
              </div>
            `}
          </div>
        </div>
      `;
    }

    render(html`<${App} />`, document.getElementById('app'));
  </script>
</body>
</html>
